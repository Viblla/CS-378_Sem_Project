# -*- coding: utf-8 -*-
"""DAA_Project_2022064.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LQ7OBtxIEcvljLLdMD44PCHqeD6s7N-n

# TSP Route Planner & Visualizer

# Dataset Info:
This project uses a dataset of 50 major cities in Pakistan.
Each city entry contains its name, latitude, and longitude.
Data Source: Manually compiled city coordinates
File used: pakistan_cities_coordinates.csv

The dataset is used to compute Euclidean distances between cities and
simulate real-world route planning using TSP algorithms.
"""

import pandas as pd
import math
import matplotlib.pyplot as plt
import itertools
import time

"""# Step 1: Load CSV and prepare city data
***Load the dataset and preview the top rows to verify structure and content***
"""

df = pd.read_csv("pakistan_cities_coordinates.csv")
print("\nDataset Preview:")
print(df.head())
print("\nTotal Cities Loaded:", len(df))

"""***Data validation: drop rows with missing or malformed coordinates***"""

df.dropna(subset=['Latitude', 'Longitude', 'City'], inplace=True)
df = df[df['Latitude'].apply(lambda x: isinstance(x, (int, float))) & df['Longitude'].apply(lambda x: isinstance(x, (int, float)))]
cities = df.to_dict(orient='records')

"""***Ask for user input***"""

start_index = int(input("Enter the index (0-based) of the start city (default is 0): ") or 0)
if start_index >= len(cities):
    print(f"Invalid start index. Resetting to 0.")
    start_index = 0
num_cities = int(input(f"Enter the number of cities to use (max {len(cities)}): ") or len(cities))
algorithm_choice = input("Choose algorithm (nn = Nearest Neighbor, bf = Brute Force, hk = Held-Karp, all = Run All): ") or "nn"

cities = cities[:num_cities]

"""# Step 2: Define distance calculation and matrix builder"""

def euclidean_distance(city1, city2):
    return math.hypot(city1["Longitude"] - city2["Longitude"], city1["Latitude"] - city2["Latitude"])

def build_distance_matrix(cities):
    n = len(cities)
    matrix = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            matrix[i][j] = euclidean_distance(cities[i], cities[j])
    return matrix

"""# Step 3: Nearest Neighbor TSP Algorithm"""

def nearest_neighbor(matrix, start=0):
    n = len(matrix)
    visited = [False]*n
    path = [start]
    visited[start] = True
    total_cost = 0
    current = start

    for _ in range(n - 1):
        next_city = min(
            [(i, matrix[current][i]) for i in range(n) if not visited[i]],
            key=lambda x: x[1]
        )[0]
        total_cost += matrix[current][next_city]
        path.append(next_city)
        visited[next_city] = True
        current = next_city

    total_cost += matrix[current][start]
    path.append(start)
    return path, total_cost

"""# Step 4: Brute Force TSP Algorithm (only for small N)"""

def brute_force_tsp(matrix):
    n = len(matrix)
    cities = list(range(n))
    min_cost = float('inf')
    best_path = []
    for perm in itertools.permutations(cities[1:]):
        current_path = [0] + list(perm) + [0]
        cost = sum(matrix[current_path[i]][current_path[i+1]] for i in range(n))
        if cost < min_cost:
            min_cost = cost
            best_path = current_path
    return best_path, min_cost

"""# Step 4B: Held-Karp TSP Algorithm (Dynamic Programming)"""

def held_karp(matrix):
    n = len(matrix)
    C = {}

    for k in range(1, n):
        C[(1 << k, k)] = (matrix[0][k], [0, k])

    for subset_size in range(2, n):
        for subset in itertools.combinations(range(1, n), subset_size):
            bits = 0
            for bit in subset:
                bits |= 1 << bit

            for k in subset:
                prev = bits & ~(1 << k)
                res = []
                for m in subset:
                    if m == k:
                        continue
                    res.append((C[(prev, m)][0] + matrix[m][k], C[(prev, m)][1] + [k]))
                C[(bits, k)] = min(res)

    bits = (2 ** n - 1) - 1
    res = []
    for k in range(1, n):
        res.append((C[(bits, k)][0] + matrix[k][0], C[(bits, k)][1] + [0]))
    cost, path = min(res)
    return path, cost

"""# Step 5: Visualize the path using matplotlib"""

from mpl_toolkits.mplot3d import Axes3D

def plot_tsp_path(cities, path, algorithm_name, cost):
    x = [cities[i]['Longitude'] for i in path]
    y = [cities[i]['Latitude'] for i in path]
    labels = [cities[i]['City'] for i in path]

    plt.figure(figsize=(12, 8))
    plt.plot(x, y, 'o-', markersize=8)
    for i, label in enumerate(labels):
        plt.annotate(f"{i+1}. {label}", (x[i], y[i]), fontsize=9)
    plt.title(f"TSP Path - {algorithm_name} | Cost: {round(cost, 2)}")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.grid(True)
    plt.show()

def plot_tsp_path_3d(cities, path, algorithm_name, cost):
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    x = [cities[i]['Longitude'] for i in path]
    y = [cities[i]['Latitude'] for i in path]
    z = list(range(len(path)))
    ax.plot(x, y, z, marker='o')
    for i, city_idx in enumerate(path):
        ax.text(x[i], y[i], z[i], f"{i+1}. {cities[city_idx]['City']}", size=8)
    ax.set_title(f"3D TSP Path - {algorithm_name} | Cost: {round(cost, 2)}")
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_zlabel('Visit Order')
    plt.tight_layout()
    plt.show()

def plot_comparison_chart(results):
    names = [r["name"] for r in results]
    costs = [r["cost"] for r in results]
    times = [r["time"] for r in results]
    fig, ax1 = plt.subplots(figsize=(10, 6))
    ax2 = ax1.twinx()
    ax1.bar(names, costs, color='skyblue', label='Path Cost')
    ax2.plot(names, times, color='orange', marker='o', label='Execution Time (s)')
    ax1.set_ylabel('Path Cost')
    ax2.set_ylabel('Execution Time (seconds)')
    ax1.set_title("TSP Algorithm Comparison")
    ax1.grid(True)
    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')
    plt.tight_layout()
    plt.show()

    # Final recommendation based on lowest cost
    summary_df = pd.DataFrame(results)
    best_algo = summary_df.loc[summary_df['cost'].idxmin()]
    print(f"✅ Recommendation: Use '{best_algo['name']}' as it gives the lowest path cost of {round(best_algo['cost'], 2)}.")
    fastest_algo = summary_df.loc[summary_df['time'].idxmin()]
    if fastest_algo['name'] != best_algo['name']:
        print(f"⚡ Also, '{fastest_algo['name']}' is the fastest algorithm with execution time {round(fastest_algo['time'], 4)} seconds.")

"""# Step 6: Execute selected algorithm"""

if num_cities > len(cities):
    print(f"Requested {num_cities} cities, but only {len(cities)} are available. Reducing to maximum available.")
    num_cities = len(cities)
cities = cities[:num_cities]
matrix = build_distance_matrix(cities)
results = []

if algorithm_choice == "nn":
    print("--- Running Nearest Neighbor Algorithm ---")
    start_time = time.time()
    path, cost = nearest_neighbor(matrix, start=start_index)
    elapsed = time.time() - start_time
    print("Nearest Neighbor Path Cost:", round(cost, 2))
    print("Time:", round(elapsed, 4), "seconds")
    algo_name = "Nearest Neighbor"
    assert path[0] == path[-1], "Path must return to starting city."
    assert len(set(path[:-1])) == len(path) - 1, "Each city should be visited exactly once."
    plot_tsp_path(cities, path, algo_name, cost)
    plot_tsp_path_3d(cities, path, algo_name, cost)
    results.append({"name": algo_name, "cost": cost, "time": elapsed})

elif algorithm_choice == "bf":
    print("--- Running Brute Force Algorithm ---")
    if num_cities > 10:
        print("Warning: Brute Force may take a long time for more than 10 cities.")
    start_time = time.time()
    path, cost = brute_force_tsp(matrix)
    elapsed = time.time() - start_time
    print("Brute Force Path Cost:", round(cost, 2))
    print("Time:", round(elapsed, 4), "seconds")
    algo_name = "Brute Force"
    assert path[0] == path[-1], "Path must return to starting city."
    assert len(set(path[:-1])) == len(path) - 1, "Each city should be visited exactly once."
    plot_tsp_path(cities, path, algo_name, cost)
    plot_tsp_path_3d(cities, path, algo_name, cost)
    results.append({"name": algo_name, "cost": cost, "time": elapsed})

elif algorithm_choice == "hk":
    print("--- Running Held-Karp Algorithm ---")
    start_time = time.time()
    path, cost = held_karp(matrix)
    elapsed = time.time() - start_time
    print("Held-Karp Path Cost:", round(cost, 2))
    print("Time:", round(elapsed, 4), "seconds")
    algo_name = "Held-Karp"
    assert path[0] == path[-1], "Path must return to starting city."
    assert len(set(path[:-1])) == len(path) - 1, "Each city should be visited exactly once."
    plot_tsp_path(cities, path, algo_name, cost)
    plot_tsp_path_3d(cities, path, algo_name, cost)
    results.append({"name": algo_name, "cost": cost, "time": elapsed})

elif algorithm_choice == "all":
    for algo_code, algo_fn, name in [("nn", nearest_neighbor, "Nearest Neighbor"),
                                     ("bf", brute_force_tsp, "Brute Force"),
                                     ("hk", held_karp, "Held-Karp")]:
        if algo_code == "bf" and num_cities > 10:
            print("--- Skipping Brute Force Algorithm due to large number of cities ---")
            continue
        print(f"--- Running {name} Algorithm ---")
        start_time = time.time()
        path, cost = algo_fn(matrix) if algo_code != "nn" else algo_fn(matrix, start=start_index)
        elapsed = time.time() - start_time
        print(f"{name} Path Cost:", round(cost, 2))
        print("Time:", round(elapsed, 4), "seconds")
        assert path[0] == path[-1], "Path must return to starting city."
        assert len(set(path[:-1])) == len(path) - 1, "Each city should be visited exactly once."
        plot_tsp_path(cities, path, name, cost)
        plot_tsp_path_3d(cities, path, name, cost)
        results.append({"name": name, "cost": cost, "time": elapsed})
summary_df = pd.DataFrame(results)
print("--- Final Summary Table ---")
if summary_df.empty:
    print("No algorithms were run. Please select a valid algorithm option.")
else:
    print(summary_df)
    plot_comparison_chart(results)